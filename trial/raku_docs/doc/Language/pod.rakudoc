=begin pod :kind("Language") :subkind("Language") :category("reference")

=TITLE Rakudoc - formerly POD6

=SUBTITLE An easy-to-use markup language for documenting Raku modules and programs

Rakudoc is an easy-to-use markup language. It can be used for
writing language documentation, for documenting programs and modules, as
well as for other types of document composition.

Every Rakudoc document has to begin with C<=begin pod> and end with C<=end pod>.
Everything between these two delimiters will be processed and used to generate
documentation.

=begin code
=begin pod

A very simple Rakudoc document

=end pod
=end code

=head1 Block structure

A Rakudoc document may consist of multiple Rakudoc blocks (also called pod locks). There are four ways to
define a block: delimited, paragraph, abbreviated, and declarator; the first three
yield the same result but the fourth differs. You can use whichever form is most
convenient for your particular documentation task.

=head2 Delimited blocks

Delimited blocks are bounded by C<=begin> and C<=end> markers, both of
which are followed by a valid Raku identifier, which is the
C<typename> of the block. Typenames that are entirely lowercase (for
example: C<=begin head1>) or entirely uppercase (for example: C<=begin
SYNOPSIS>) are reserved. Indentation of the =begin/=end lines is
required to be the same to create a valid block; otherwise, an error
or unexpected results will occur.

=begin code
=begin head1
Top Level Heading
=end head1
=end code

=head2 Configuration information

After the typename, the rest of the C<=begin> marker line is treated as
configuration information for the block. This information is used in
different ways by different types of blocks, but is always specified using
Raku-ish option pairs. That is, any of:

=begin table
 Value is...       Specify with...           Or with...           Or with...
 ===============   ===================       ==============       ===========
 List              :key[$e1, $e2, ...]       :key($e1, $e2, ...)  :key<$e1 $e2 ...>
 Hash              :key{$k1=>$v1, $k2=>$v2}
 Boolean (true)    :key                      :key(True)           :key[True]
 Boolean (false)   :!key                     :key(False)          :key[False]
 String            :key<str>                 :key('str')          :key("str")
 Int               :key(42)                  :key[42]             :42key
 Number            :key(2.3)                 :key[2.3]
=end table

Where '$e1, $e2, ...' are list elements of type String, Int, Number, or
Boolean. Lists may have mixed element types. Note that one-element
lists are converted to the type of their element (String, Int, Number, or
Boolean). Also note that big integers can be used if required.

For hashes, '$k1, $k2, ...' are keys of type Str and '$v1, $v2, ...'
are values of type String, Int, Number, or Boolean.

Strings are delimited by single or double quotes. Whitespace is not significant
outside of strings. Hash keys need not be quote-delimited unless they contain
significant whitespace. Strings entered inside angle brackets become lists if
any whitespace is used inside the angle brackets.

All option keys and values must be constants since Rakudoc is a
specification language, not a programming language. Specifically, option
values cannot be closures.

The configuration section may be extended over subsequent
lines.
Each subsequent line must start
with an C<=> in the first virtual column, meaning that it must vertically
align with the C<=> of the Rakudoc Block declaration,
and it must be followed
by at least one horizontal whitespace character.

For example:
=begin code
     =for head1 :a-first-line-key<firstvalue> :another-first-line-key<xyz>
     =          :a-second-line-key(42)
     = :a-third-line-key<third>
     Content for the header block
=end code

=head2 Standard configuration options

Rakudoc predefines a small number of standard configuration options that can be applied
appropriate block types. These include:
C<:numbered>
=begin nested
This option specifies that the block is to be numbered. This option is to
create L<numbered headings|#Numbered headings> and L<ordered lists|#Ordered lists>,
but it can be applied to any block if the Renderer provides a way to do so (eg. via a
specific template).

The numbering conventions for headings and lists are specified in those sections,
but it is up to individual renderers to decide how to display any numbering associated
with other types of blocks.

Note that numbering is never explicit; it is always implied by context.
=end nested

C<:template<my-special> >
=begin nested
This option is a C<Raku::Pod::Render> extension and subsumes the originally specified (but never
implemented) C<:formatted>, <:nested> and <:margin> options.

A pod-block is normally rendered using default templates. It is possible to add new templates to the
template list, and for the code block to be rendered using the new template.

This option tells the Renderer to render the pod-block with the C<my-special> template.
See L<Adding new templates for existing Pod::Blocks |#Adding_new_templates_for_existing_Pod::Blocks>
for an example.
=end nested

C<:toc>
=begin nested
This option is a C<Raku::Pod::Render> extension. See C<:headlevel> below too.

By default C<Nested> and C<Para> blocks are NOT placed in the Table of Contents. If it is desired
to place one of these blocks in the Table of contents, then C<:toc> can be set. It is probably best
also to set C<:toc-caption> as well (see below).

By default Named pod-blocks are placed in the Table of Contents. By setting C<:!toc> (note that a
False value is being specified), the
contents section of the Name block is not placed in the Table of Contents.

See below in L<Custom blocks distributed with C<Raku::Pod::Render>|#Custom_blocks_distributed_with_Raku::Pod::Render>
for some examples.
=end nested

C<:headlevel(dd)>
=begin nested
This option is a C<Raku::Pod::Render> extension.

Named pod-blocks are by default considered to be the same level (significantly for the Table of Contents)
as C<=head1>. For custom blocks this may not be desired.

For example a diagram may be "inside" a section with C<=head2> block. So by setting C<:headlevel(3)>
as the metadata for the Custom block, it will appear in the Table of Contents at the appropriate
level.

C<:headlevel> takes precedence over C<:toc>. If C<:toc> is set and C<:headlevel> is not set, then
C<:toc> sets C<$headlevel> to 1, and C<:!toc> sets C<$headlevel> to 0.

=end nested

C<:toc-caption<A caption text> >
=begin nested
This option is a C<Raku::Pod::Render> extension.

Some Custom blocks (eg., Latex below) expect the contents of the block to be used for the custom
behaviour. Normally, C<:!toc> would be included with the metadata to exclude the contents from
being included in the Table of Contents.

If it is desired to include a reference to the block in the Table of Contents, but not the contents
then C<:toc-caption> can be included in the block meta data.

This option is not valid for a C<=head> type block.

=end nested

Some of these options have a predetermined value; specifically, C<:numbered>
is used to specify that the block item or lines will be numbered.

This configuration option can be abbreviated by a hash mark

=begin code
=para #
We
Need
Numbers

say $=pod[0].config<numbered>; # OUTPUT: «1␤»
=end code

=head2 Block pre-configuration

This directive is not available prior to C<Raku::Pod::Render>.

The C<=config> directive has the form

=begin code
    =config block-name :metadata<some-value>
=end code

C<=config> directives apply from the time they are encountered until the end of the enclosing Pod-block.

For example, to specify particular formatting for different levels of heading, you could preconfigure all the heading blocks with appropriate formatting schemes:
=begin code
    =config head1 :template<SerifHeaderBold>  :numbered
    =config head2 :template<SansHeader>
    =config head3 :template<SerifHeader>
    =config head4 :template<SerifHeader>
=end code

where I<SerifHeaderBold> etc are new templates provided by the user.

The data is provided to each template in the parameter C<config>. C<config> is a hash whose keys are the name
of the block, eg., head1, item1, code. The values associated with a key are also hashes,
containing the pair values of the metadata.

=head2 Outermost pod configuration

C<Raku::Pod::Render> provides some file-specific data to all Pod-blocks, and also the meta data specified in
the outermost Pod::Block::Named `pod`. The following data are provided:
=item name => basename of the Rakudoc file (without extension)
=item path => relative url to file from root of collection (with extension)
=item lang => language (or En by default)
=item all metadata associated with the outer C<=begin rakudoc> or C<=begin pod> block is considered
Config data too.

In addition the following metadata associated with the outermost pod block are treated specially:

=begin item
B<:no-toc>

=for nested
Do not create a Table of Contents

=end item
=begin item
B<:no-glossary>
=for nested
Do not create a Glossary (aka Index) for the document (a glossary contains all the items that are
marked up with the V<X<>> format code.

=end item
=begin item
B<:no-footnotes>
=for nested
Do not generate any footnotes on the page even if they is a V<N<>> markup in the source.

=end item

A C<=config> is a directive, not a block. Hence, there is no paragraph or delimited form of the C<=config>
directive. Each C<=config> specification is lexically scoped to the surrounding block in which it is specified,
(but only after it has been specified).

Note that, if a particular block later explicitly specifies a configuration option with the same key,
that option overrides the pre-configured option.

=head2 Paragraph blocks

Paragraph blocks begin by a C<=for> marker and end by
the next Rakudoc directive or the first blank line.
The C<=for> marker is followed by the C<typename> of the block
plus, optionally, any configuration data as in the delimited
blocks described above.

=begin code
=for head1
Top Level Heading
=end code

=head2 Abbreviated blocks

Abbreviated blocks begin by an C<'='> sign, which is followed immediately by the
C<typename> of the block. All following data are part of the contents of the
block, thus configuration data B<cannot> be specified for an I<abbreviated>
block. The block ends at the next Rakudoc directive or the first blank line.

=begin code
=head1 Top level heading
=end code

X<|Syntax,#|>X<|Syntax,#=>
=head2 Declarator blocks

Declarator blocks differ from the others by not having a specific type,
instead they are attached to some source code.

Declarator blocks are introduced by a special comment: either C<#|> or C<#=>,
which must be immediately followed by either a space or an opening curly brace.
If followed by a space, the block is terminated by the end of line;
if followed by one or more opening curly braces, the block is terminated by
the matching sequence of closing curly braces.

Blocks starting with C<#|> are attached to the code after them,
and blocks starting with C<#=> are attached to the code before them.

Since declarator blocks are attached to source code, they can be used to
document classes, roles, subroutines and in general any statement or block.

The C<WHY> method can be used on these classes, roles, subroutines etc. to
return the attached Rakudoc value.

=begin code
#| Base class for magicians
class Magician {
  has Int $.level;
  has Str @.spells;
}

#| Fight mechanics
sub duel(Magician $a, Magician $b) {
}
#= Magicians only, no mortals.

say Magician.WHY; # OUTPUT: «Base class for magicians␤»
say &duel.WHY.leading; # OUTPUT: «Fight mechanics␤»
say &duel.WHY.trailing; # OUTPUT: «Magicians only, no mortals.␤»
=end code

These declarations can extend multiple blocks:

=begin code
#|( This is an example of stringification:
    * Numbers turn into strings
    * Regexes operate on said strings
    * C<with> topicalizes and places result into $_
)
sub search-in-seq( Int $end, Int $number ) {
    with (^$end).grep( /^$number/ ) {
        .say for $_<>;
    }
}
#=« Uses
    * topic
    * decont operator
»
=end code

By using a matched pair of parenthesis constructs such as C<()> or C<«»> the
comments can extend multiple lines. This format will not normally translate to
a multi-line display by C<raku --doc>. However, since Rakudo version 2020.01,
there is a method to accomplish that, I<for leading declarator blocks only>,
by defining a special environment variable: B<C<RAKUDO_POD_DECL_BLOCK_USER_FORMAT>>.
When that value is set, running C<raku> with the C<--doc> option should show text
from leading declarator blocks in its original format. See the test for the capability
in the file
L<S26-documentation/block-leading-user-format.t|https://github.com/Raku/roast/blob/master/S26-documentation/block-leading-user-format.t>.

=head1 Block types

Rakudoc offers a wide range of standard block types.

=head2 Headings

Headings can be defined using C<=headN>,
where N is greater than zero (e.g., C<=head1>, C<=head2>, …).

=begin code
=head1 A top level heading

=head2 A second level heading

=head3 A third level heading
=end code

=head2 Ordinary paragraphs

An ordinary paragraph consists of text that is to be formatted into a document
at the current level of nesting, with whitespace squeezed, lines filled, and any
special inline mark-up applied.

Ordinary paragraphs consist of one or more consecutive lines of text,
each of which starts with a non-whitespace character.
The paragraph is terminated by the first blank line or block directive.

For example:

=begin code
=head1 This is a heading block

This is an ordinary paragraph.
Its text  will   be     squeezed     and
short lines filled. It is terminated by
the first blank line.

This is another ordinary paragraph.
Its     text    will  also be squeezed and
short lines filled. It is terminated by
the trailing directive on the next line.

=head2 This is another heading block

This is yet another ordinary paragraph,
at the first virtual column set by the
previous directive
=end code

Ordinary paragraphs do not require an explicit marker or delimiters.

Alternatively, there is also an explicit C<=para> marker that can be used
to explicitly mark a paragraph.

=begin code
=para
This is an ordinary paragraph.
Its text  will   be     squeezed     and
short lines filled.
=end code

which is rendered as:

=para
This is an ordinary paragraph.
Its text  will   be     squeezed     and
short lines filled.

In addition, the longer C<=begin para> and C<=end para> form can be used.

For example:

=begin code

=begin para
This is an ordinary paragraph.
Its text  will   be     squeezed     and
short lines filled.

This is still part of the same paragraph,
which continues until an...
=end para
=end code

As demonstrated by the previous example, within a delimited C<=begin para> and
C<=end para> block, any blank lines are preserved.

=head3 Formatting within code blocks

Although C<=code> blocks automatically disregard all formatting codes, occasionally you may still
need to specify some formatting within a code block. For example, you may wish to
emphasize a particular keyword in an example (using a C<B<>> code). Or you may want to indicate that
part of the example is metasyntactic (using the C<R<>> code). Or you might need to insert a non-ASCII
character (using the C<E<>> code).

You can specify a list of formatting codes that should still be recognized within a code block using
the C<:allow> option. The value of the C<:allow> option must be a list of the (single-letter)
names of one or more formatting codes. Those codes will then remain active inside the code block.
For example:
=begin code
    =begin code :allow< B R >
    sub demo {
        B<say> 'Hello R<name>';
        I<note> 'The I format is not recognised';
    }
    =end code
=end code

would be rendered:

=begin code :allow< B R >
sub demo {
    B<say> 'Hello R<name>';
    I<note> 'The I format is not recognised';
    }
=end code

=head2 I/O blocks

Rakudoc provides blocks for specifying the input and output of programs.

=for nested
B<Note> The Rakudo compiler does not (yet) produce C<Pod::Block>s for Input or Output
and instead produces C<Pod::Block::Code> for C<=code>, C<=input> and C<=output>.

The C<=input> block is used to specify pre-formatted keyboard input,
which should be rendered without re-justification or squeezing of whitespace.

The C<=output> block is used to specify pre-formatted terminal or file output,
which should also be rendered without re-justification or whitespace-squeezing.
=begin code :lang<rakudoc>

    =begin output
            Name:    Baracus, B.A.
            Rank:    Sgt
            Serial:  1PTDF007

            Do you want additional personnel details? K<y>

            Height:  180cm/5'11"
            Weight:  104kg/230lb
            Age:     49

            Print? K<n>
        =end output

=end code

=head2 Lists

Lists in Rakudoc are specified as a series of contiguous C<=item> blocks.
No special "container" directives or other delimiters are required to enclose the entire list.

Note that C<=item> is just an abbreviation for C<=item1>.

Item blocks within the same list are not physically nested.
That is, lower-level items should not be specified inside higher-level items:
=begin code

    =comment WRONG...
    =begin item1          --------------
    The choices are:                    |
    =item2 Liberty        ==< Level 2   |==<  Level 1
    =item2 Death          ==< Level 2   |
    =item2 Beer           ==< Level 2   |
    =end item1            --------------

    =comment CORRECT...
    =begin item1          ---------------
    The choices are:                     |==< Level 1
    =end item1            ---------------
    =item2 Liberty        ==================< Level 2
    =item2 Death          ==================< Level 2
    =item2 Beer           ==================< Level 2
=end code

=head3 Unordered lists

Lists in Rakudoc are by default unordered. For example:

=begin code
The three suspects are:

=item  Happy
=item  Sleepy
=item  Grumpy
=end code

The three suspects are:

=item  Happy
=item  Sleepy
=item  Grumpy

The bulletting strategy used for different levels within a nested list is entirely up to the renderer.

=head3 Ordered lists

An item is part of an ordered list if the item has a :numbered configuration option:
=begin code
     =for item1 :numbered
     Visito

     =for item2 :numbered
     Veni

     =for item2 :numbered
     Vidi

     =for item2 :numbered
     Vici
=end code
This would produce something like:
=begin nested
1. Visito

1.1. Veni

1.2. Vidi

1.3. Vici
=end nested

=for item1 :numbered
Visito

=for item2 :numbered
Veni

=for item2 :numbered
Vidi

=for item2 :numbered
Vici

although the numbering scheme is entirely at the discretion of the renderer,
so it might equally well be rendered:

1. Visito

1a. Veni

1b. Vidi

1c. Vici

or even:

A: Visito

  (i) Veni

 (ii) Vidi

(iii) Vici

Alternatively, if the first word of the item consists of a single # character, the item is treated as having a :numbered option:

     =item1  # Visito
     =item2     # Veni
     =item2     # Vidi
     =item2     # Vici

To specify an unnumbered list item that starts with a literal #, either make the octothorpe verbatim:

    =item V<#> introduces a comment

or explicitly mark the item itself as being unnumbered:

    =for item :!numbered
    # introduces a comment

The numbering of successive =item1 list items increments automatically, but is reset to 1 whenever any other kind of non-ambient Pod block appears between two =item1 blocks. For example:

    The options are:

    =item1 # Liberty
    =item1 # Death
    =item1 # Beer

    The tools are:

    =item1 # Revolution
    =item1 # Deep-fried peanut butter sandwich
    =item1 # Keg

would produce:

The options are:

1. Liberty

2. Death

3. Beer

The tools are:

1. Revolution

2. Deep-fried peanut butter sandwich

3. Keg

The numbering of nested items (=item2, =item3, etc.) only resets (to 1) when the higher-level item's numbering either resets or increments.

To prevent a numbered =item1 from resetting after a non-item block, you can specify the :continued option:

     =for item1
     # Retreat to remote Himalayan monastery

     =for item1
     # Learn the hidden mysteries of space and time

     I<????>

     =for item1 :continued
     # Prophet!

which produces:

1. Retreat to remote Himalayan monastery

2. Learn the hidden mysteries of space and time

????

3. Prophet!

=head3 Definition lists

Lists that define terms or commands use C<=defn>, equivalent to the C<DL> lists
in HTML

=begin code
=defn Happy
When you're not blue.

=defn Blue
When you're not happy.
=end code

will be rendered as

=defn Happy
When you're not blue.

=defn Blue
When you're not happy.

=head3 Multi-level lists

Lists may be multi-level, with items at each level specified using the
C<=item1>, C<=item2>, C<=item3>, etc. blocks.
(The indentation depends on the rendering engine and does not need to be included
in the Rakudoc markup.) Upto four levels are normally differentiated.

For example:

=begin code
=item1  Animal
=item2     Vertebrate
=item3     Mammals
=item4     Primates
=item2     Invertebrate

=item1  Phase
=item2     Solid
=item3        Crystaline
=item3        Amorphous
=item2     Liquid
=item2     Gas
=end code

=item1  Animal
=item2     Vertebrate
=item3     Mammals
=item4     Primates
=item2     Invertebrate

=item1  Phase
=item2     Solid
=item3        Crystaline
=item3        Amorphous
=item2     Liquid
=item2     Gas

=head3 Multi-paragraph lists

Using the delimited form of the C<=item> block (C<=begin item> and C<=end item>),
we can specify items that contain multiple paragraphs.

For example:

=begin code
Let's consider two common proverbs:

=begin item
I<The rain in Spain falls mainly on the plain.>

This is a common myth and an unconscionable slur on the Spanish
people, the majority of whom are extremely attractive.
=end item

=begin item
I<The early bird gets the worm.>

In deciding whether to become an early riser, it is worth
considering whether you would actually enjoy annelids
for breakfast.
=end item

As you can see, folk wisdom is often of dubious value.
=end code
Renders as:

Let's consider two common proverbs:

=begin item
I<The rain in Spain falls mainly on the plain.>

This is a common myth and an unconscionable slur on the Spanish
people, the majority of whom are extremely attractive.
=end item

=begin item
I<The early bird gets the worm.>

In deciding whether to become an early riser, it is worth
considering whether you would actually enjoy annelids
for breakfast.
=end item

As you can see, folk wisdom is often of dubious value.

=head2 Nested blocks

Rakudoc provides a C<=nested> block that marks all its contents as being nested:
=begin code
    =begin nested
    We are all of us in the gutter,

    but some of us are looking at the stars!
        =begin nested
        -- Oscar Wilde
        =end nested
    =end nested
=end code

=begin nested
We are all of us in the gutter,

but some of us are looking at the stars!
    =begin nested
    -- Oscar Wilde
    =end nested
=end nested

Nesting blocks can contain any other kind of block, including implicit paragraph and code blocks.
Note that the relative physical indentation of the blocks plays no role in determining
their ultimate nesting. The preceding example could equally have been specified:
=begin code
    =begin nested
    We are all of us in the gutter,

    but some of us are looking at the stars!
    =begin nested
    -- Oscar Wilde
    =end nested
    =end nested
=end code

=begin nested
We are all of us in the gutter,

but some of us are looking at the stars!
=begin nested
-- Oscar Wilde
=end nested
=end nested

=head2 Tables

Check out this page for documentation related to L<Tables|/language/tables>
Z<Eventually copy everything from tables.rakudoc and put it here>

=head2 Rakudoc comments

Rakudoc comments are comments that Rakudoc renderers ignore.

Comments are useful for I<meta>documentation (documenting the documentation).
Single-line comments use the C<=comment> marker:

=begin code
=comment Add more here about the algorithm
=end code

For multi-line comments, use a delimited C<comment> block:

=begin code
=begin comment
This comment is
multi-line.
=end comment
=end code

=head2 Semantic blocks

All uppercase block typenames are reserved for specifying standard
documentation, publishing, source components, or metainformation.

=begin code
=NAME
=AUTHOR
=VERSION
=TITLE
=SUBTITLE
=end code

=head1 Formatting codes

Formatting codes provide a way to add inline mark-up to a piece of text.

All Rakudoc formatting codes consist of a single capital letter followed immediately
by a set of single or double angle brackets; Unicode double angle brackets may
be used.

Formatting codes may nest other formatting codes.

The following codes are available: B<B>, B<C>, B<E>, B<I>, B<K>, B<L>, B<N>,
B<P>, B<R>, B<T>, B<U>, B<V>, B<X>, and B<Z>.

=head2 Bold

To format a text in bold enclose it in C<B< >>
=for code
Raku is B<awesome>

Raku is B<awesome>

=head2 Italic

To format a text in italic enclose it in C<I< >>
=for code
Raku is I<awesome>

Raku is I<awesome>

=head2 Underlined

To underline a text enclose it in C<U< >>
=for code
Raku is U<awesome>

Raku is U<awesome>

=head2 Code

To flag text as code and treat it verbatim enclose it in C<C< >>
=for code
C<my $var = 1; say $var;>

C<my $var = 1; say $var;>

=head2 Links

To create a link enclose it in C<L< >>

A vertical bar (optional) separates label and target.

The target location can be an URL (first example) or a local Rakudoc document
(second example). Local file names are relative to the base of the project, not
the current document.

=for code
Raku homepage L<https://raku.org>
L<Raku homepage|https://raku.org>

Raku homepage L<https://raku.org>

L<Raku homepage|https://raku.org>

=for code
Structure L</language/about#Structure|/language/about#Structure>
L<Structure|/language/about#Structure>

Structure L</language/about#Structure|/language/about#Structure>

L<Structure|/language/about#Structure>

To create a link to a section in the same document:
=for code
Comments L<#Comments>
L<Comments|#Comments>

Comments L<#Comments>

L<Comments|#Comments>

Alongside the normal way of describing a path, viz. C«L<Some reference|path/to/filename>», it is also
possible to use the module-style notation, e.g., C«L<Some reference|path::to::filename>».

=head2 Placement links

This code is not implemented in C<Pod::To::HTML>, but it is implemented
in C<Raku::Pod::Render>.

A second kind of link E<mdash> the C<P<>> or B<placement link> E<mdash> works
in the opposite direction. Instead of directing focus out to another
document, it allows you to assimilate the contents of another document
into your own.

In other words, the C<P<>> formatting code takes a URI and (where possible)
inserts the contents of the corresponding document inline in place of the
code itself.

C<P<>> codes are handy for breaking out standard elements of
your documentation set into reusable components that can then be
incorporated directly into multiple documents. For example:

=begin code
=COPYRIGHT
P<file:/shared/docs/std_copyright.rakudoc>

=DISCLAIMER
P<http://www.MegaGigaTeraPetaCorp.com/std/disclaimer.txt>
=end code

might produce:

=begin nested
B<Copyright>

=nested This document is copyright (c) MegaGigaTeraPetaCorp, 2006. All rights reserved.

B<Disclaimer>

=begin nested
ABSOLUTELY NO WARRANTY IS IMPLIED. NOT EVEN OF ANY KIND. WE HAVE SOLD
YOU THIS SOFTWARE WITH NO HINT OF A SUGGESTION THAT IT IS EITHER USEFUL
OR USABLE. AS FOR GUARANTEES OF CORRECTNESS...DON'T MAKE US LAUGH! AT
SOME TIME IN THE FUTURE WE MIGHT DEIGN TO SELL YOU UPGRADES THAT PURPORT
TO ADDRESS SOME OF THE APPLICATION'S MANY DEFICIENCIES, BUT NO PROMISES
THERE EITHER. WE HAVE MORE LAWYERS ON STAFF THAN YOU HAVE TOTAL
EMPLOYEES, SO DON'T EVEN *THINK* ABOUT SUING US. HAVE A NICE DAY.
=end nested
=end nested

If a renderer cannot find or access the external data source for a
placement link, it must issue a warning and render the URI directly in
some form, possibly as an outwards link. For example:

=begin nested
B<Copyright>

=nested See: C<file:/shared/docs/std_copyright.rakudoc>

B<Disclaimer>

=nested See: L<http://www.MegaGigaTeraPetaCorp.com/std/disclaimer.txt>
=end nested

You can use any of the following URI forms (see L<#Links>) in a
placement link.

=head2 Comments

A comment is text that is never rendered.

To create a comment enclose it in C<Z< >>
=for code
Raku is awesome Z<Of course it is!>

Raku is awesome Z<Of course it is!>

=head2 Notes

Notes are rendered as footnotes.

To create a note enclose it in C<N< >>
=for code
Raku is multi-paradigmatic N<Supporting Procedural, Object Oriented, and Functional programming>

Raku is multi-paradigmatic N<Supporting Procedural, Object Oriented, and Functional programming>

=head2 Keyboard input

To flag text as keyboard input enclose it in C<K< >>
=for code
Enter your name K<John Doe>

Enter your name K<John Doe>

=head2 Replaceable

The C<R<>> formatting code specifies that the contained text is a
B<replaceable item>, a placeholder, or a metasyntactic variable. It is
used to indicate a component of a syntax or specification that should
eventually be replaced by an actual value. For example:

=begin code
The basic C<ln> command is: C<ln> R<source_file> R<target_file>
=end code

The basic C<ln> command is: C<ln> R<source_file> R<target_file>

=head2 Terminal output

To flag text as terminal output enclose it in C<T< >>
=for code :lang<rakudoc>
Hello T<John Doe>

Hello T<John Doe>

=head2 Unicode

To include Unicode code points or HTML5 character references in a Rakudoc document,
enclose them in C<E< >>

C<E< >> can enclose a number, which is treated as the decimal Unicode
value for the desired code point. It can also enclose explicit binary, octal,
decimal, or hexadecimal numbers using the Raku notations for explicitly based
numbers.

=begin code
Raku makes considerable use of the E<171> and E<187> characters.

Raku makes considerable use of the E<laquo> and E<raquo> characters.

Raku makes considerable use of the E<0b10101011> and E<0b10111011> characters.

Raku makes considerable use of the E<0o253> and E<0o273> characters.

Raku makes considerable use of the E<0d171> and E<0d187> characters.

Raku makes considerable use of the E<0xAB> and E<0xBB> characters.
=end code

Raku makes considerable use of the « and » characters.

=head2 Verbatim text

This code is not implemented by C<Pod::To::HTML>, but is implemented in
C<Raku::Pod::Render>.

The C<V<>> formatting code treats its entire contents as being B<verbatim>,
disregarding every apparent formatting code within it. For example:

=for code
The B<V< V<> >> formatting code disarms other codes
such as V< I<>, C<>, B<>, and M<> >.

Note, however that the C<V<>> code only changes the way its
contents are parsed, I<not> the way they are rendered. That is, the
contents are still wrapped and formatted like plain text, and the
effects of any formatting codes surrounding the C<V<>> code
are still applied to its contents. For example the previous example
is rendered as:

=nested
The B<V< V<> >> formatting code disarms other codes
such as V< I<>, C<>, B<>, and M<> >.

=head2 Indexing terms

Anything enclosed in an C<X<>> code is an B<index entry>. The contents
of the code are both formatted into the document and used as the
(case-insensitive) index entry:

=begin code :allow<B> :lang<rakudoc>
An B<X<array>> is an ordered list of scalars indexed by number,
starting with 0. A B<X<hash>> is an unordered collection of scalar
values indexed by their associated string key.
=end code

You can specify an index entry in which the indexed text and the index
entry are different, by separating the two with a vertical bar:

=begin code :allow<B> :lang<rakudoc>
An B<X<array|arrays>> is an ordered list of scalars indexed by number,
starting with 0. A B<X<hash|hashes>> is an unordered collection of
scalar values indexed by their associated string key.
=end code

In the two-part form, the index entry comes after the bar and is
case-sensitive.

You can specify hierarchical index entries by separating indexing levels
with commas:

=begin code :allow<B> :lang<rakudoc>
An X<array|B<arrays, definition of>> is an ordered list of scalars
indexed by number, starting with 0. A X<hash|B<hashes, definition of>>
is an unordered collection of scalar values indexed by their
associated string key.
=end code

You can specify two or more entries for a single indexed text, by separating
the entries with semicolons:

=begin code :allow<B> :lang<rakudoc>
A X<hash|B<hashes, definition of; associative arrays>>
is an unordered collection of scalar values indexed by their
associated string key.
=end code

The indexed text can be empty, creating a "zero-width" index entry:

=begin code :allow<B> :lang<rakudoc>
B<X<|puns, deliberate>>This is called the "Orcish Maneuver"
because you "OR" the "cache".
=end code

=head1 Rendering Pod

=head2 HTML

There are currently two ways to render HTML from Pod:
=item L<The Pod::To::HTML module|https://github.com/Raku/Pod-To-HTML>.
=item L<The Raku::Pod::Render module|https://github.com/finanalyst/raku-pod-render>

Both can be installed using zef, eg.
    zef install Raku::Pod::Render

C<Pod::To::HTML> is an older module and does not implement all of the functionality
in this document. But it is simpler to use.

Once installed, run the following command in the terminal:
=begin code :lang<shell>
raku --doc=HTML input.rakudoc > output.html
=end code

C<Raku::Pod::Render> is used to generate the HTML on this website. It also allows for
custom blocks, that is C<=some-name> Named blocks. These blocks can be written by
a developer specially for a specific site, and can be used to include CSS, JS, JQuery elements,
or access a micro service. More information can be found in the documentation in the
distribution.

Some custom blocks that come with C<Raku::Pod::Render> are shown below.

=head2 Markdown

In order to generate Markdown from Pod, you need
the L<Pod::To::Markdown module|https://github.com/softmoth/perl6-pod-to-markdown>.

If it is not already installed, install it by running the following command:
C<zef install Pod::To::Markdown>

Once installed, run the following command in the terminal:
=begin code :lang<shell>
raku --doc=Markdown input.rakudoc > output.md
=end code

=head2 Text

In order to generate text from Pod, you can use the default
C<Pod::To::Text> module.

Using the terminal, run the following command:
=begin code :lang<shell>
raku --doc=Text input.rakudoc > output.txt
=end code

You can omit the C<=Text> portion:

=begin code :lang<shell>
raku --doc input.rakudoc > output.txt
=end code

You can even embed Rakudoc directly in your program and add the
traditional Unix command line "--man" option to your program with a
multi MAIN subroutine like this:

=begin code
multi MAIN(Bool :$man) {
    run $*EXECUTABLE, '--doc', $*PROGRAM;
}
=end code

Now C<myprogram --man> will output your Rakudoc rendered as a man page.

=head1 Accessing Pod

In order to access Rakudoc documentation from within a Raku program the
special C<=> twigil, as documented
in the L<variables section|/language/variables#The_=_twigil>, must be used.

The C<=> twigil provides the introspection over the Rakudoc structure,
providing a L<Pod::Block|/type/Pod::Block> tree root from which it is possible
to access the whole structure of the Rakudoc document.

As an example, the following piece of code introspects
its own Rakudoc documentation:

=begin code
=begin pod

=head1 This is a head1 title

This is a paragraph.

=head2 Subsection

Here some text for the subsection.

=end pod

for $=pod -> $pod-item {
    for $pod-item.contents -> $pod-block {
      $pod-block.raku.say;
    }
}
=end code

producing the following output:

=for code
Pod::Heading.new(level => 1, config => {}, contents => [Pod::Block::Para.new(config => {}, contents => ["This is a head1 title"])]);
Pod::Block::Para.new(config => {}, contents => ["This is a paragraph."]);
Pod::Heading.new(level => 2, config => {}, contents => [Pod::Block::Para.new(config => {}, contents => ["Subsection"])]);
Pod::Block::Para.new(config => {}, contents => ["Here some text for the subsection."]);

=head1 Custom blocks distributed with C<Raku::Pod::Render>

A Custom block is placed by default in the Table of Contents as if it was a
C<=head1>. Sometimes a block should not be listed in the Table of Contents,
so use the metadata C<:!toc>. Sometimes, a block is wanted in the Table of
Content, but at a different level, eg. the same as a C<=head3>, in which
case, use the metadata C<:headlevel(3)>.

=head2 Colourful line breaks

The block was developed as a simple custom block to show how new CSS can be
associated with common HTML elements.

=begin code
=for HR :class<yellowish-dots> :!toc

=for HR :class<bluish-dots> :!toc

=for HR :class<greenish-dots> :!toc

=end code

renders as

=for HR :class<yellowish-dots> :!toc

=for HR :class<bluish-dots> :!toc

=for HR :class<greenish-dots> :!toc

=head2 Adding new templates for existing Pod::Blocks

Suppose you want a different template to act on an existing block, like Para,
which is coded as HTML C< <p> >. For example,
=begin code :allow< V >
I like this sonnet:
=for para :template<quotation> V<:author<William Shakespeare> > V<:citation<Sonnet 116>> :!toc
Let me not to the marriage of true minds\n
Admit impediments; love is not love\n
Which alters when it alteration finds,\n
Or bends with the remover to remove.
=end code

I like this sonnet:
=for para :template<quotation> :author<William Shakespeare> :citation<Sonnet 116> :!toc
Let me not to the marriage of true minds\n
Admit impediments; love is not love\n
Which alters when it alteration finds,\n
Or bends with the remover to remove.

=head2 FontAwesome icons

The difference between a B<Pod-block> and a B<FormatCode> is that a block is line oriented,
where as format codes are word/character oriented and can appear inside a line.

Since Raku treats all Unicode characters the same, Chinese/Arabic/Cyrillic glyphs can now be
specified to repeat or alias the predefined codes of C<B C I K T U E Z X N L P V >.
This means a character/glyph more appropriate in another language can be used in place of,
for example B<B> for bold.

Here V< F<> > is used to include a Fontawesome icon.
See L<font search page|https://fontawesome.com/icons>.
Make sure to filter for the free icons.

=begin code
Some FontAwesome icons

F<fas fa-ambulance> Example of ambulance

F<fas fa-car> Example of automobile

F<fas fa-bicycle> Example of bicycle

F<fas fa-bus> Example of bus

F<fas fa-truck> Example of truck

F<fas fa-wheelchair> Example of wheelchair

F<fas fab-accessible-icon> Example of accessible-icon (was wheelchair-alt in fontawesom v4)
=end code

Generates
Some FontAwesome icons

F<fas fa-ambulance> Example of ambulance

F<fas fa-car> Example of automobile

F<fas fa-bicycle> Example of bicycle

F<fas fa-bus> Example of bus

F<fas fa-truck> Example of truck

F<fas fa-wheelchair> Example of wheelchair

F<fab fa-accessible-icon> Example of accessible-icon (was wheelchair-alt in fontawesome v4)

FontAwesome has some other options.
=begin code

Train normal size F<fas fa-train> Triple size train F<fas fa-train|fa-3x>

An animated spinner F<fas fa-sync|fa-spin fa-3x fa-fw>
=end code
Generates

Train normal size F<fas fa-train> Triple size train F<fas fa-train|fa-3x>

An animated spinner F<fas fa-sync|fa-spin fa-3x fa-fw>

=head2 Graphviz

This block introduces a directed graph in the dot language. It is rendered into HTML as an svg using the
dot program. Since a graph data is require, only the delimited form of the block (starting with =begin/=end)
will be used.

The following diagraph comes from the C<dot> documentation. The following Rakudoc
=begin code
=begin Graphviz :toc-caption<Digraph example> :headlevel(3)
    digraph G {
        main -> parse -> execute;
        main -> init;
        main -> cleanup;
        execute -> make_string;
        execute -> printf
        init -> make_string;
        main -> printf;
        execute -> compare;
    }
=end Graphviz
=end code

produces

=begin Graphviz :toc-caption<Digraph example> :headlevel(3)
    digraph G {
        main -> parse -> execute;
        main -> init;
        main -> cleanup;
        execute -> make_string;
        execute -> printf
        init -> make_string;
        main -> printf;
        execute -> compare;
    }
=end Graphviz

=head2 Latex

This plugin block sends the Latex markup to the CodeCogs online equation editor. For example,

=begin code
=for Latex :!toc
\begin{align*}
\sum_{i=1}^{k+1} i^{3}
&= \biggl(\sum_{i=1}^{n} i^{3}\biggr) +  i^3\\
&= \frac{k^{2}(k+1)^{2}}{4} + (k+1)^3 \\
&= \frac{k^{2}(k+1)^{2} + 4(k+1)^3}{4}\\
&= \frac{(k+1)^{2}(k^{2} + 4k + 4)}{4}\\
&= \frac{(k+1)^{2}(k+2)^{2}}{4}
\end{align*}
=end code

=for Latex :!toc
\begin{align*}
\sum_{i=1}^{k+1} i^{3}
&= \biggl(\sum_{i=1}^{n} i^{3}\biggr) +  i^3\\
&= \frac{k^{2}(k+1)^{2}}{4} + (k+1)^3 \\
&= \frac{k^{2}(k+1)^{2} + 4(k+1)^3}{4}\\
&= \frac{(k+1)^{2}(k^{2} + 4k + 4)}{4}\\
&= \frac{(k+1)^{2}(k+2)^{2}}{4}
\end{align*}

=end pod
