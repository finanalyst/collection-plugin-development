=begin pod
=TITLE Development of Collection Plugins

=head1 Introduction

The C<Collection> module makes extensive use of plugins. They need developing and maintaining.

The intention is for this distribution (Collection-Plugin-Development)
to be associated with the repository for the files to develop plugins, and the current working
copies of plugins.

Another repository (Collection-Plugins) is the source for published / released Collection plugins.

So, the work flow is
=item new plugins are added, modified, developed in C<Collection::Plugins>
=item modified plugins are prepared for release & pushed to Collection::Plugins using

    prepare-plugins

It can be called with
=item C<-repo> pointing to where the released plugins are kept. The default is C<-repo=~/.local/share/Collection> and
=item C<-origin> pointing to where the working versions of plugins are kept. The default is C<-origin=lib>

Alternatively

    prepare-plugins :rebuild

This creates a C<manifest.rakuon> file in the C<-repo> default.

The program can be called with C<-repo> as specified above.

The program
=item creates a manifest.rakuon file in the root of C<:repo>.
=item creates a release version for new / changed plugins in C<:repo>

It is left to the developer to git add/commit/push the files.

=head1 Collection plugin specification

All Collection plugins must conform to the following rules
=item The plugin name must:
=item2 start with a letter
=item2 followed by at least one \w or \-
=item2 not contain \_ or \.
=item2 thus a name matches / <alpha> <[\w] + [\-] - [\_]>+ /
=item The plugin directory contains
=item2 C<config.raku>, which is a file that evaluates to a Raku hash.
=item2 README.rakudoc
=item2 t/01-basic.rakutest
=item The C<config.raku> file must contain the following keys
=item2 C<name>. This is the released name of the plugin. It will be possible for a new plugin to have the same
functionality as another, while extending or changing the output. For more detail, see L<Collection plugin management system>.
Typically, the name of the plugin will match the name of the sub-directory it is in.

=item2 C<version>. This point to a Str in the format \d+\.\d+\.\d+ which matches the semantic version
conventions.

=item2 C<auth>. This points to a Str that is consistent with the Raku 'auth' conventions.
=item2 C<license>. Points to a SPDX license type.
=item2 C<authors>. This points to a sequence of names of people who are the authors of the plugin.
=item2 one or more of C<render setup report compilation completion>
=item3 If render then
=item4 the render key may be a boolean
=item4 or the render key is a Str which must
=item5 be a filename in the directory
=item5 be a raku program that evaluated to a callable
=item5 the callable has a signature defined for render callables
=item4 the key C<custom-raku>
=item5 must exist
=item5 must either be empty, viz. C<custom-raku()>
=item5 or must have a Str value
=item5 if it has a Str value and the key C<:information> does contain C<custom-raku> then it is treated
as if C<custom-raku> is empty

=item5 if it has a Str value and the key C<:information> does NOT contain C<custom-raku> then
the Str value should

=item6 point to a file name in the current directory
=item6 and the filename should contain a Raku program that evaluates to an Array.
=item4 the key C<template-raku>
=item5 must exist
=item5 must either be empty, viz. C<template-raku()>
=item5 or must have a Str value
=item5 if it has a Str value and the key C<:information> does contain C<template-raku> then it is treated
as if C<template-raku> is empty

=item5 if it has a Str value and the key C<:information> does NOT contain C<template-raku> then
the Str value should

=item6 point to a file name in the current directory
=item6 and the filename should contain a Raku program that evaluates to a Hash.
=item3 If not render, then the value must point to a Raku program and evaluate to a callable.
=item2 I<Other key names>. If other keys are present, they must point to filenames in the
current directory.

=item2 C<information>. This key does not need to exist.
=item3 If it exists, then it must contain the names of other keys.
=item3 If a key named in the C<:information> list contains a Str,
the filename will NOT exist in the plugin directory, but will
be generated by the plugin itself, or is used as information by the plugin.
=item3 This config key is intended only for plugin testing purposes.

=head1 Collection plugin tests

This distribution contains the module C<Test::CollectionPlugins> with a single exported subroutine
C<plugin-ok>. This subroutine verifies that the plugin rules are kept for the plugin.

Additional plugin specific tests should be included.

=head1 Collection-Plugin-Development utilities

Three utilities are provided to add a new plugin, modify an existing plugin's config file (eg.
change the version number), run the tests of all plugins, and prepare plugins for release

Each utility assumes the plugin directory is at C<lib/<format>/plugins>, where the default
format is C<html>. An example of another format would be C<markdown>.

=head2 add-collection-plugin

The utility adds the necessary files (config.raku, README, a test file, and callables) for a milestone.

Only a plugin name (eg. my-new-plugin) is required, and a new html format plugin with a C<render> milestone
is set up. Eg.

    add-collection-plugin my-new-plugin

An error will be shown if an existing plugin with the same name is present in the C<lib/html/plugins>
directory.

The config file will have the defaults of the other mandatory keys. See C<modify-collection-plugin-config>
for how to get the defaults.

For different milestones set the option C<-mile> to the milestone name and a callable stub is also
created.

    add-collection-plugin -mile=setup my-new-plugin

The C<-mile> option can take a list of milestones and form stubs for each, eg.

    add-collection-plugin -mile='setup render compilation' my-new-plugin

If a new format is being developed, then set C<-format> to the chosen format name, eg C<markdown>.
A plugin will then be added to C<lib/markdown/plugins>. Eg. (for the default -mile=render)

    add-collection-plugin -format=markdown my-new-markdown-plugin

=head2 modify-collection-plugin

This utility is intended to modify an existing plugin's config file, such as adding defaults
if they are missing.

The utility cannot be used to modify a plugin's C<name> key. It will add the directory name if a name key is missing.

To get a list of default attributes use

    modify-collection-plugin-config -show-defaults

To modify a plugin specify the name with the option -plugin, eg.

    modify-collection-plugin-config -plugin=an-existing-plugin -defaults

The plugin will be given defaults to all mandatory attributes, unless they already exist,
in which case they are not changed.

To modify a specific attribute for a plugin use, for example,

    modify-collection-plugin-config -plugin=an-existing-plugin -version=0.1.2

To bumps a plugin's I<patch> version number, use

    modify-collection-plugin-config -plugin=an-existing-plugin -bump

To modify the I<Major> and I<Minor> numbers use the C<-version> option

To get help

    modify-collection-plugin-config -help

=head2 test-all-collection-plugins

All plugins must have a C<t/> directory and one test file. This utility runs all the test
files of all the plugins, returning only minimal information if the tests pass, but more
information if a test fails.

=head2 sub prepare-plugins( :$from = '../raku-collection-plugins', :$to = 'lib', :$format = 'html' )

The subroutine
=item Moves plugins that have a new version/author to release directory.
=item Verifies that there are no files in a working plugin directory that have newer content than in
a release directory.
=item Issues a suggestion to bump version if there is newer content.
=item creates a file C<manifest.rakuon> in the release directory (see later for specification of
files).

=head1 Naming of released plugin

The name of a working plugin must match C</^ <.alpha> <[\w] + [\-] - [\_]>+ $ />.

If a plugin C<my-plug> has a config file with C<:version<1.2.3>, :auth<collection> >,
then the released name will be B<my-plug_v1_auth_collection>

=head1 Collection plugin management system

It is planned to have GUI and a command line manager.

The local computer may contain
=item More than one collection, eg. a personal website and a Raku documentation collection
=item Each Collection may have more than one Mode, eg., a HTML website, an epub producer.
=item A collection/mode combination may rely on a previous API of a plugin, which may be broken
by a later API.

=item A new plugin may have been written as a drop-in replacement for an older version, and the new
plugin may have a different name, or auth, or version.

So a plugin manager (whether command line or GUI) must be compliant with the following system:
=item There is a I<release> directory to contain all Collection plugins, probably a clone of the
github repository.

=item The semantic versioning scheme is mandated for Collection plugins. A version is
C<v<major>.<minor>,<patch>>. Changes at the C< <patch> > level do not affect the plugin's functionality.
Changes at the C< <minor> > level introduce new functionality, but are backward compatible.
Changes at the C< <major> > level break backward compatibility.

=item Each distributed plugin is contained in the release directory in a subdirectory
named by the plugin name, the
auth field, and the major version number (minor and patch numbers are not included because
they should not by definition affect the API).

=item Each Mode configuration only contains the name of the plugin (without the auth, or version names).
=item The developer may define which name/version/auth of a released plugin is to be mapped
to the plugin required in the Mode configuration. Thus

=item2 changes in API can be frozen to earlier versions of the plugin for some concrete Mode.
=item2 different plugin versions can be used for different collection/modes
=item2 a differently named plugin can be mapped to a plugin required by a specific collection/mode.

=item Consequently, all released plugins are defined for
=item2 a Format (eg. html)
=item2 a Major version
=item2 an Auth name
=item The mapping information from a released plugin to a Mode is contained in a file in the root
of a Collection.

=item When the plugins are updated
=item2 all the latest versions for each I<relevant> Format/Name/Version-Major/Auth are downloaded.
=item2 a symlink is generated (or if the OS does not allow symlink, the whole directory is copied)
from the released version to the directory where
each mode expects its plugins to be located.
=item2 The meaning of I<relevant> is determined by the PMS. It could be all plugins in the github
repository, or only those needed by a specific Collection, or set of Collections.

=head2 System implementation

Each Collection root directory (the directory containing the topmost C<config.raku> file)
will contain the file C<plugins.rakuon>.

=item The plugin management tool (PMT)
=item2 runs through the plugins-required
=item2 for each distinct plugin verifies whether
=item3 the plugin has an entry in C<plugins.rakuon>, in which case
=item4 the PMT maps the released plugin name/auth/ver to the plugin-required name using the rules
of C<plugins.rakuon> as given below
=item3 the released version matches the plugin version (the full major.minor.patch version)
=item2 if a released version has larger minor/patch values, then the new directory is linked
(copied) to the Mode's plugin name

The file C<plugin.raku> contains a hash with the following keys:
=item C<collection-plugin-root> This contains the name of a directory reachable from the Collection
root directory with the released plugins are downloaded.

=item Every other toplevel key is interpreted as a Mode. It will point to a hash with the keys:
=item2 C<FORMAT> Each mode may only contain plugins from one Format, eg., I<html>.
=item2 This implies that a I<Mode> may not be named C<FORMAT>.
=item2 Every other key at this level (meaning within the hash for a Mode and not equal to C<FORMAT>)
must be a plugin name contained in the Mode's plugins-required configuration.

=item3 The C<plugins-required> hash has plugins for each milestone, when a plugin may have a callable
for several milestones. So only unique plugin names are implied here.

=item2 There may be zero other keys at this level
=item2 If a plugin in the plugins-required configuration list does B<not> have an entry
at this level, then the plugin has just been added to the plugins-required list and needs to be
downloaded.

=item2 If a plugin key exists, it must point to a Hash, which must contain
=item3 the version number of the existing plugin, or '' if it needs downloading
=item2 The plugin Hash may also contain one of the following keys
=item3 Name => the name of an alternative plugin
=item4 the default name is the plugin-required's name
=item4 if a different name is given, a released plugin is mapped to the required directory in the
mode sub-directory

=item3 Major => the major number of a full version preceeded by 'v'
=item4 the default value is the greatest released major value
=item4 A Major value is the maximum Major version permitted, thus freezing at that version
=item3 Auth => the auth value
=item4 the default value is 'collection'

Some examples:
=begin item
The Raku-Collection-Raku-Documentation, Website mode, requires the plugin C<Camelia>. The plugin exists
as a HTML format. It has version 1.0.0, and an auth 'collection'. It is distributed as
C<html/camelia_v_1_auth_collection>. Suppose a version with a new API is created. Then
two versions of the plugin will be distributed, including the new one
C<html/camelia_v_2_auth_collection>.

If the key for camelia in the hash for mode Website only contains an empty C<version> key,
then the defaults will be implied and
a link (or copy) will be made between the released directory
C<html/camelia_auth_collection__ver_2> and C<Website/plugins/camelia>
=end item
=begin item
If plugins.rakuon contains the following:
C<Website => %( :FORMAT<html>, :camelia( %( :major(1), ) ) >
then the link will be between C<html/camelia_auth_collection__ver_1> and C<Website/plugins/camelia>
=end item
=begin item
Suppose there is another valid C<auth> string B<raku-dev> and there is a distributed plugin
I<html/camelia_auth_raku-dev__ver_2>, and suppose C<plugins.rakuon> contains the following:
C<Website => %( :FORMAT<html>, :camelia( %( :auth<raku-dev>, ) ) > then the link will be made
between C<html/camelia_auth_raku-dev__ver_2> and C<Website/plugins/camelia>
=end item
=begin item
Suppose a different icon is developed called C<new-camelia> by C<auth> B<raku-dev>, then
C<plugins.rakuon> may contain the following:
C<Website => %( :FORMAT<html>, camelia( %( :name<new-camelia>, :auth<raku-dev>, ) ) > then
a link (copy) is made between C<html/new-camelia_auth_raku-dev__ver_2> and C<Website/plugins/camelia>
=end item
=item2 Note how the auth must be given for a renaming if there is not a C<collection> version
of the plugin

=head1 Specification of manifest.rakuon file

C<manifest.rakuon> evaluates to a Hash.

The keys of the Hash match the directory structure until the plugin names. Then there is a
full version number. For example,

    %( plugins => %(
        html => %(
            camelia_V0_auth_collection => %(
                version => '0.1.0'
            ),
        ),
    )


=head1 Currently

The 'clean' directory structure is
=item plugins-for-release/ # the directory / repository for released plugins
=item2 lib/plugins # location of operating plugins
=item2 trial/ # the directory in which testing is run
=item3 raku-docs/ # a small collection of Raku documentation docs
=item3 Website/ # the directory containing the website mode configuration/plugins
=item4 plugins/ # a link pointing to /lib/plugins + format
=item4 structure-sources/collections-examples.rakudoc # demo file for all user-facing plugins
=item3 config.raku # the configuration file for trial/Website/
=item2 bin/add-new-plugin # adds a new plugin
=item2 bin/test-all-collection-plugins # tests each plugin and the templates
=item2 bin/prepare-plugins # moves plugins from operating directory to release directory
=item2 updateCSS # a bash file to run SCSS files in selected plugins

The workflow is for changes to be made in Website, run Raku-Doc,
inspect the result in C<localhost:3000>, and iterate.

=end pod