=begin pod
=TITE Readme
=SUBTITLE Plugins for Collection

=head1 Introduction

The C<Collection> module makes extensive use of plugins. They need developing and maintaining.

The intention is for this distribution to be the repository for the files to develop plugins, and
as a source for completed working plugins.

=head1 Collection plugin specification

All Collection plugins must conform to the following rules
=item The plugin directory contains
=item2 C<config.raku>, which is a file that evaluates to a Raku hash.
=item2 README.rakudoc
=item2 t/01-basic.rakutest
=item The C<config.raku> must contain the following keys
=item2 one or more of C<render setup report compilation completion>
=item3 If render then
=item4 the render key may be a boolean
=item4 or the render key is a Str which must
=item5 be a filename in the directory
=item5 be a raku program that evaluated to a callable
=item5 the callable has a signature defined for render callables
=item4 the key C<custom-raku>
=item5 must exist
=item5 must either be empty, viz. C<custom-raku()>
=item5 or must have a Str value
=item5 if it has a Str value and the key C<:information> does contain C<custom-raku> then it is treated
as if C<custom-raku> is empty

=item5 if it has a Str value and the key C<:generate> does NOT contain C<custom-raku> then
the Str value should

=item6 point to a file name in the current directory
=item6 and the filename should contain a Raku program that evaluates to an Array.
=item4 the key C<template-raku>
=item5 must exist
=item5 must either be empty, viz. C<template-raku()>
=item5 or must have a Str value
=item5 if it has a Str value and the key C<:information> does contain C<template-raku> then it is treated
as if C<template-raku> is empty

=item5 if it has a Str value and the key C<:information> does NOT contain C<template-raku> then
the Str value should

=item6 point to a file name in the current directory
=item6 and the filename should contain a Raku program that evaluates to a Hash.

=item3 If not render, then the value must point to a Raku program and evaluate to a callable.

=item2 C<version>. This point to a Str in the format \d+\.\d+\.\d+ which matches the semantic version
conventions.

=item2 C<auth>. This points to a Str that is consistent with the Raku 'auth' conventions.
=item2 C<license>. Points to a SPDX license type.
=item2 C<authors>. This points to a sequence of names of people who are the authors of the plugin.
=item2 I<Other key names>. If other keys are present, they must point to filenames in the
current directory.

=item2 C<information>. This key does not need to exist.
=item3 If it exists, then it must contain the names of other keys.
=item3 If a key named in the C<:information> list contains a Str,
the filename will NOT exist in the plugin directory, but will
be generated by the plugin itself, or is used as information by the plugin.
=item3 This config key is intended only for plugin testing purposes.

=head1 Collection plugin tests

This distribution contains the module C<Test::CollectionPlugins> with a single exported subroutine
C<plugin-ok>. This subroutine verifies that the plugin rules are kept for the plugin.

Additional plugin specific tests should be included.

=head1 Collection utilities

Three utilities are provided to add a new plugin, modify an existing plugin's config file (eg.
change the version number, and run the tests of all plugins.

Each utility assumes the plugin directory is at C<lib/<format>/plugins>, where the default
format is C<html>. An example of another format would be C<markdown>.

=head2 add-collection-plugin

The utility adds the necessary files (config.raku, README, a test file, and callables) for a milestone.

Only a plugin name (eg. my-new-plugin) is required, and a new html format plugin with a C<render> milestone
is set up. Eg.

    add-collection-plugin my-new-plugin

An error will be shown if an existing plugin with the same name is present in the C<lib/html/plugins>
directory.

The config file will have the defaults of the other mandatory keys. See C<modify-collection-plugin-config>
for how to get the defaults.

For different milestones set the option C<-mile> to the milestone name and a callable stub is also
created.

    add-collection-plugin -mile=setup my-new-plugin

The C<-mile> option can take a list of milestones and form stubs for each, eg.

    add-collection-plugin -mile='setup render compilation' my-new-plugin

If a new format is being developed, then set C<-format> to the chosen format name, eg C<markdown>.
A plugin will then be added to C<lib/markdown/plugins>. Eg. (for the default -mile=render)

    add-collection-plugin -format=markdown my-new-markdown-plugin

=head2 modify-collection-plugin

This utility is intended to modify an existing plugin's config file, such as adding defaults
if they are missing. To get a list of default attributes use

    modify-collection-plugin-config -show-defaults

To modify a plugin specify the name with the option -plugin, eg.

    modify-collection-plugin-config -plugin=an-existing-plugin -defaults

The plugin will be given defaults to all mandatory attributes, unless they already exist,
in which case they are not changed.

To modify a specific attribute for a plugin use, for example,

    modify-collection-plugin-config -plugin=an-existing-plugin -version=0.1.2

To bumps a plugin's I<patch> version number, use

    modify-collection-plugin-config -plugin=an-existing-plugin -bump

To get help

    modify-collection-plugin-config -help

=head2 test-all-collection-plugins

All plugins must have a C<t/> directory and one test file. This utility runs all the test
files of all the plugins, returning only minimal information if the tests pass, but more
information if a test fails.

=head1 Collection plugin management system

It is planned to have GUI and a command line manager.

The local computer may contain
=item More than one collection, eg. a personal website and a Raku documentation collection
=item Each Collection may have more than one Mode, eg., a HTML website, an epub producer.
=item A collection/mode combination may rely on a previous API of a plugin, which may be broken
by a later API.

=item A new plugin may have been written as a drop-in replacement for an older version, and the new
plugin may have a different name, or auth, or version.

So a plugin manager (whether command line or GUI) must be compliant with the following system:
=item There is a I<release> directory to contain all Collection plugins, probably a clone of the
github repository.

=item The semantic versioning scheme is mandated for Collection plugins. A version is
C<v<major>.<minor>,<patch>>. Changes at the C< <patch> > level do not affect the plugin's functionality.
Changes at the C< <minor> > level introduce new functionality, but are backward compatible.
Changes at the C< <major> > level break backward compatibility.

=item Each distributed plugin is contained in the release directory in a subdirectory
named by the plugin name, the
auth field, and the major version number (minor and patch numbers are not included because
they should not by definition affect the API).

=item Each Mode configuration only contains the name of the plugin (without the auth, or version names).
=item The developer may define which name/version/auth of a released plugin is to be mapped
to the plugin required in the Mode configuration. Thus

=item2 changes in API can be frozen to earlier versions of the plugin for some concrete Mode.
=item2 different plugin versions can be used for different collection/modes
=item2 a differently named plugin can be mapped to a plugin required by a specific collection/mode.

=item Consequently, all released plugins are defined for
=item2 a Format (eg. html)
=item2 a Major version
=item2 an Auth name
=item The mapping information from a released plugin to a Mode is contained in a file in the root
of a Collection.

=item When the plugins are updated
=item2 all the latest versions for each Format/Name/Version/Auth are downloaded.
=item2 a symlink is generated (or if the OS does not allow symlink, the whole directory is copied)
from the released version to the directory where
each mode expects its plugins to be located.

To implement this system
=item Each Collection root directory (the directory containing the topmost C<config.raku> file)
will contain the file C<plugin.conf>.
=item The plugin management tool (PMT)
=item2 runs through the plugins-required
=item2 for each distinct plugin verifies whether
=item3 the plugin has an entry in C<plugin.conf>, in which case
=item4 the PMT maps the released plugin name/auth/ver to the plugin-required name using the rules
of C<plugin.conf> as given below
=item3 the released version matches the plugin version (the full major.minor.patch version)
=item2 if a released version has larger minor/patch values, then the new directory is linked
(copied) to the Mode's plugin name

The file C<plugin.raku> contains a hash with the following keys:
=item C<collection-plugin-root> This contains the name of a directory reachable from the Collection
root directory with the released plugins are downloaded.

=item Every other toplevel key is interpreted as a Mode. It will point to a hash with the keys:
=item2 C<FORMAT> Each mode may only contain plugins from one Format, eg., I<HTML>.
=item2 This implies that a I<Mode> may not be named C<FORMAT>.
=item2 Every other key at this level (meaning within the hash for a Mode and not FORMAT)
must be a plugin name contained in the Mode's plugins-required configuration.

=item2 There may be zero other keys at this level
=item2 If a plugin in the plugins-required configuration list does not have an entry
at this level, then the values for that plugin are the defaults.

=item2 If a key exists, it must point to a Hash, which must contain at least one of the following keys
=item3 Name => the name of the plugin
=item4 the default name is the plugin-required's name
=item4 if a different name is given, a released plugin is mapped to the required directory in the
mode sub-directory

=item3 Major => the major number preceeded by 'v'
=item4 the default value is the greatest released major value
=item4 A Major value is the maximum Major version permitted, thus freezing at that version
=item3 Auth => the auth value
=item4 the default value is 'finanalyst'
=item2 If there is no distributed plugin for a specified C<auth>, then an error is thrown.

Some examples:
=begin item
The Raku-Collection-Raku-Documentation, Website mode, requires the plugin C<Camelia>. The plugin exists
as a HTML format. It has version 1.0.0, and an auth 'finanalyst'. It is distributed as
C<html/camelia_auth_finanalyst__ver_1>. Suppose a version with a new API is created. Then
two versions of the plugin will be distributed, including the new one
C<html/camelia_auth_finanalyst__ver_2>.

If no key for camelia is in the hash for mode Website, then the defaults will be implimented and
a link (or copy) will be made between the released directory
C<html/camelia_auth_finanalyst__ver_2> and C<Website/plugins/camelia>
=end item
=begin item
If plugin.conf contains the following:
C<Website => %( :FORMAT<html>, :camelia( %( :major(1), ) ) >
then the link will be between C<html/camelia_auth_finanalyst__ver_1> and C<Website/plugins/camelia>
=end item
=begin item
Suppose there is another valid C<auth> string B<raku-dev> and there is a distributed plugin
I<html/camelia_auth_raku-dev__ver_2>, and suppose C<plugin.conf> contains the following:
C<Website => %( :FORMAT<html>, :camelia( %( :auth<raku-dev>, ) ) > then the link will be made
between C<html/camelia_auth_raku-dev__ver_2> and C<Website/plugins/camelia>
=end item
=begin item
Suppose a different icon is developed called C<new-camelia> by C<auth> B<raku-dev>, then the
plugin.conf file may contain the following:
C<Website => %( :FORMAT<html>, camelia( %( :name<new-camelia>, :auth<raku-dev>, ) ) > then
a link (copy) is made between C<html/new-camelia_auth_raku-dev__ver_2> and C<Website/plugins/camelia>
=end item
=item2 Note how the auth must be given for a renaming if there is not a C<finanalyst> version
of the plugin

=head1 Currently

The 'clean' directory structure is
=item raku-collection-plugins/ # the root of the module
=item2 lib/html/plugins # location of plugin data
=item2 resources/ # a directory for the Module
=item2 trial/ # the directory in which testing is run
=item3 raku-docs/ # a small collection of Raku documentation docs
=item3 Website/ # the directory containing the website mode configuration/plugins
=item4 plugins/ # a link pointing to /lib/html/plugins
=item4 structure-sources/collections-examples.rakudoc # demo file for all user-facing plugins
=item3 config.raku # the configuration file for trial/Website/
=item2 add-new-plugin # adds a new plugin
=item2 test-plugins # tests each plugin and the templates
=item2 updateCSS # a bash file to run SCSS files in selected plugins

The workflow is for changes to be made in Website, run Raku-Doc,
inspect the result in C<localhost:3000>, and iterate.

=end pod